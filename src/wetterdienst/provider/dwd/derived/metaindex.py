# Copyright (C) 2018-2025, earthobservations developers.
# Distributed under the MIT License. See LICENSE for more info.
"""Metadata for DWD climate derived."""

from __future__ import annotations

import itertools
import logging
from typing import TYPE_CHECKING

import pandas as pd
import polars as pl

from wetterdienst.metadata.cache import CacheExpiry
from wetterdienst.provider.dwd.derived.metadata import SOIL_DATASETS, DwdDerivedMetadata
from wetterdienst.util.network import File, download_file

if TYPE_CHECKING:
    from collections.abc import Generator

    from wetterdienst.model.metadata import DatasetModel
    from wetterdienst.settings import Settings


log = logging.getLogger(__name__)

DWD_COLUMN_NAMES_MAPPING = {
    "column_1": "station_id",
    "column_2": "start_date",
    "column_3": "end_date",
    "column_4": "height",
    "column_5": "latitude",
    "column_6": "longitude",
    "column_7": "name",
    "column_8": "state",
}

SOIL_COLUMN_NAMES_MAPPING = {
    "Stationsindex": "station_id",
    "Höhe in m": "height",
    "Breite": "latitude",
    "Länge": "longitude",
    "Name": "name",
    "Bundesland": "state",
}

COL_SPECS = [
    (0, 5),  # Stations_id
    (5, 15),  # von_datum
    (15, 35),  # bis_datum
    (35, 43),  # Stationshoehe
    (43, 53),  # geoBreite
    (53, 60),  # geoLaenge
    (61, 101),  # Stationsname
    (102, 143),  # Bundesland # (144,1000) # Abgabe
]

_STATION_URL_DICT = {
    DwdDerivedMetadata.monthly.heating_degreedays.name: "https://opendata.dwd.de/climate_environment/CDC/help/KL_Monatswerte_Beschreibung_Stationen.txt",
    DwdDerivedMetadata.monthly.cooling_degreehours_13.name: "https://opendata.dwd.de/climate_environment/CDC/help/KL_Monatswerte_Beschreibung_Stationen.txt",
    DwdDerivedMetadata.monthly.cooling_degreehours_16.name: "https://opendata.dwd.de/climate_environment/CDC/help/KL_Monatswerte_Beschreibung_Stationen.txt",
    DwdDerivedMetadata.monthly.cooling_degreehours_18.name: "https://opendata.dwd.de/climate_environment/CDC/help/KL_Monatswerte_Beschreibung_Stationen.txt",
    DwdDerivedMetadata.hourly.radiation_global.name: "https://opendata.dwd.de/climate_environment/CDC/help/fg_duett_Beschreibung_Stationen.txt",
    DwdDerivedMetadata.hourly.sunshine_duration.name: "https://opendata.dwd.de/climate_environment/CDC/help/sd_duett_Beschreibung_Stationen.txt",
    DwdDerivedMetadata.daily.soil.name: "https://opendata.dwd.de/climate_environment/CDC/help/stations_list_soil.txt",
}


def create_meta_index_for_climate_derived(
    dataset: DatasetModel,
    settings: Settings,
) -> pl.LazyFrame:
    """Create metadata DataFrame for derived climate data."""
    if dataset.name == DwdDerivedMetadata.monthly.climate_correction_factor.name:
        return _get_raw_station_data_from_plz_generator()
    url = _STATION_URL_DICT.get(dataset.name)
    if url is None:
        error_msg = f"Unknown dataset: {dataset.name}"
        raise ValueError(error_msg)

    downloaded_file = download_file(
        url=url,
        cache_dir=settings.cache_dir,
        ttl=CacheExpiry.METAINDEX,
        client_kwargs=settings.fsspec_client_kwargs,
        cache_disable=settings.cache_disable,
        use_certifi=settings.use_certifi,
    )
    downloaded_file.raise_if_exception()

    return _read_meta_df(dataset, file=downloaded_file)


def _generate_digit_combinations(number_of_digits: int = 5) -> Generator[str]:
    """Create a generator of all possible combinations of digits 0-9.

    This is mainly used to generate all possible postal codes (PLZ),
    when setting the number of digits to 5.

    :param number_of_digits: How many digits are included in the combination
    :return: Generator of strings containing the combinations
    """
    return (
        "".join(str(digit) for digit in combination_of_digits)
        for combination_of_digits in itertools.product(range(10), repeat=number_of_digits)
    )


def _get_raw_station_data_from_plz_generator() -> pl.LazyFrame:
    """Get proxy station data containing all possible postals codes (PLZ) as station ID.

    The rest of the columns required by the library are filled with NULLs.

    :return: Proxy station data as lazy DataFrame
    """
    autogenerated_station_data = pl.DataFrame(
        {
            "station_id": _generate_digit_combinations(),
        },
        schema={"station_id": pl.String},
    ).lazy()
    return autogenerated_station_data.with_columns(
        pl.lit(None, dtype=pl.String).alias("name"),
        pl.lit(None, dtype=pl.String).alias("state"),
        pl.lit(None, dtype=pl.Float64).alias("latitude"),
        pl.lit(None, dtype=pl.Float64).alias("longitude"),
        pl.lit(None, dtype=pl.Float64).alias("height"),
        pl.lit(None, dtype=pl.Datetime(time_zone="UTC")).alias("start_date"),
        pl.lit(None, dtype=pl.Datetime(time_zone="UTC")).alias("end_date"),
    )


def _read_meta_df(dataset: DatasetModel, file: File) -> pl.LazyFrame:
    """Read meta file into DataFrame."""
    if dataset in SOIL_DATASETS:
        df = pl.read_csv(
            file.content,
            separator=";",
            has_header=True,
            encoding="latin-1",
            skip_rows=0,
            new_columns=SOIL_COLUMN_NAMES_MAPPING.values(),
            schema={
                "station_id": pl.Int64,
                "height": pl.Float64,
                "latitude": pl.Float64,
                "longitude": pl.Float64,
                "name": pl.String,
                "state": pl.String,
            },
        ).lazy()
        df = df.with_columns(
            pl.lit(None).cast(pl.Datetime(time_zone="UTC")).alias("start_date"),
            pl.lit(None).cast(pl.Datetime(time_zone="UTC")).alias("end_date"),
            pl.col("name").str.strip_chars(),
            pl.col("state").str.strip_chars(),
            pl.col("station_id").cast(str).str.pad_start(5, "0"),
        )
    else:
        df = pd.read_fwf(
            file.content,
            header=None,
            encoding="latin-1",
            colspecs=COL_SPECS,
            skiprows=[0, 1],
        )
        df.columns = DWD_COLUMN_NAMES_MAPPING.values()
        df = pl.DataFrame(
            df,
            schema={
                "station_id": pl.Int64,
                "start_date": str,
                "end_date": str,
                "height": pl.Float64,
                "latitude": pl.Float64,
                "longitude": pl.Float64,
                "name": str,
                "state": str,
            },
        ).lazy()

        df = df.with_columns(
            pl.col("station_id").cast(str).str.pad_start(5, "0"),
            pl.col("name").str.strip_chars(),
            pl.col("state").str.strip_chars(),
            pl.col("start_date").str.to_datetime("%Y%m%d", time_zone="UTC", strict=False),
            pl.col("end_date").str.to_datetime("%Y%m%d", time_zone="UTC", strict=False),
        )
    return df
